# Chat Request Payloads - Navigation Service

This document describes the WebSocket message payloads that can be sent to the
navigation-service for chat functionality.

## Overview

The navigation-service exposes a WebSocket endpoint at `/ws/chat` that accepts
JSON-formatted messages for real-time chat communication. The service supports
both text and audio messages with session management and message counting.

## WebSocket Connection

### Endpoint

```text
ws://localhost:8081/ws/chat
```

### Connection Info API

```http
GET /api/chat/websocket/info
```

Returns connection details and sample message formats.

## Request Message Format

### Basic Text Message

```json
{
  "type": "message",
  "content": "Hello, this is a test message",
  "sessionId": "optional-session-id"
}
```

### Voice Message with Audio

```json
{
  "type": "message",
  "content": "This is the transcribed text from voice input",
  "sessionId": "optional-session-id",
  "audio": {
    "data": "base64-encoded-audio-data",
    "mimeType": "audio/webm;codecs=opus",
    "size": 12345
  }
}
```

## Request Fields

### Required Fields

| Field | Type | Description |
|-------|------|-------------|
| `type` | string | Message type, typically "message" |
| `content` | string | The text content of the message |

### Optional Fields

| Field | Type | Description |
|-------|------|-------------|
| `sessionId` | string | Optional session ID. Server generates if not provided |
| `audio` | object | Audio data object for voice messages |

### Audio Object Fields

| Field | Type | Description |
|-------|------|-------------|
| `data` | string | Base64-encoded audio data |
| `mimeType` | string | MIME type (e.g., "audio/webm;codecs=opus") |
| `size` | number | Size of the original audio blob in bytes |

## Response Message Format

### Successful Response

```json
{
  "type": "response",
  "content": "Message received: \"Hello, this is a test message\"",
  "messageCount": 1,
  "sessionId": "generated-session-id",
  "timestamp": 1703123456789,
  "hasAudio": false
}
```

### Voice Message Response

```json
{
  "type": "response",
  "content": "Voice message received: \"Text\" [Audio: audio/webm, 12345 bytes]",
  "messageCount": 2,
  "sessionId": "session-123",
  "timestamp": 1703123456789,
  "hasAudio": true
}
```

### Error Response

```json
{
  "type": "error",
  "content": "Error processing message: Invalid JSON format",
  "messageCount": 1,
  "sessionId": "session-123",
  "timestamp": 1703123456789
}
```

## Response Fields

| Field | Type | Description |
|-------|------|-------------|
| `type` | string | Response type: "response" or "error" |
| `content` | string | Response message content |
| `messageCount` | number | Sequential message count for this session |
| `sessionId` | string | Session identifier |
| `timestamp` | number | Unix timestamp in milliseconds |
| `hasAudio` | boolean | Whether the original request contained audio data |

## Audio Handling

### Supported Audio Formats

- **Primary**: `audio/webm;codecs=opus`
- **Fallback**: Browser-dependent (MP3, WAV, etc.)

### Audio Size Limits

- **WebSocket Frame Limit**: 2MB (configurable via `app.websocket.max-frame-size`)
- **Frontend Limit**: 50KB (larger files send text-only)
- **Recommended**: Keep audio under 1MB for optimal performance

### Audio Processing Flow

1. Frontend records audio using MediaRecorder API
2. Audio blob is converted to Base64 string
3. Audio data is included in WebSocket message
4. Backend logs audio metadata and acknowledges receipt
5. Future: Audio can be processed with AI services

## Session Management

### Session Creation

- Sessions are automatically created when first message is received
- Session ID is generated by the server if not provided
- Session counters track message count per session

### Session Cleanup

- Sessions are cleaned up when WebSocket connection closes
- Message counters are reset on session cleanup
- No persistent session storage (in-memory only)

## Error Handling

### Common Error Scenarios

1. **Invalid JSON**: Malformed message payload
2. **Missing Content**: Empty or missing content field
3. **Large Audio**: Audio exceeding frame size limits
4. **Connection Issues**: WebSocket disconnection during processing

### Error Response Format

All errors return a standardized error response with:

- `type: "error"`
- Descriptive error message in `content`
- Current session state preserved where possible

## Frontend Integration

### TypeScript Types

```typescript
interface ChatMessage {
  type: 'message';
  content: string;
  sessionId?: string;
  audio?: {
    data: string;
    mimeType: string;
    size: number;
  };
}

interface ChatResponse {
  type: 'response' | 'error';
  content: string;
  messageCount: number;
  sessionId: string;
  timestamp: number;
  hasAudio?: boolean;
}
```

### Example Usage

```typescript
// Text message
const textMessage = {
  type: 'message',
  content: 'Hello, navigation service!',
  sessionId: 'my-session-123'
};

// Voice message with audio
const voiceMessage = {
  type: 'message',
  content: 'This is a voice message',
  sessionId: 'my-session-123',
  audio: {
    data: audioBase64String,
    mimeType: 'audio/webm;codecs=opus',
    size: audioBlob.size
  }
};

// Send via WebSocket
websocket.send(JSON.stringify(textMessage));
```

## Configuration

### WebSocket Configuration

- **Max Frame Size**: Configurable via `app.websocket.max-frame-size` (default: 2MB)
- **Handler Mapping**: `/ws/chat` endpoint
- **Protocol**: WebSocket with JSON message format

### Development Settings

- **Local URL**: `ws://localhost:8081/ws/chat`
- **Docker URL**: `ws://navigation-service:8081/ws/chat`
- **IDE Profile**: Uses port 8081 for navigation-service

## Future Enhancements

### Planned Features

1. **AI Integration**: Process audio with speech-to-text services
2. **Navigation Commands**: Parse navigation intents from messages
3. **Context Awareness**: Include page context in requests
4. **Message History**: Persistent conversation storage
5. **User Authentication**: Session-based user identification

### Extensible Message Types

The current implementation supports extending message types:

- Navigation commands
- System commands
- File uploads
- Rich media content

## Testing

### Manual Testing

Use the demo application at `http://localhost:3001` to test:

1. Text message sending
2. Voice input with audio recording
3. Session management
4. Error handling

### WebSocket Testing Tools

- Browser DevTools WebSocket inspector
- Postman WebSocket collections
- Custom WebSocket test clients

## Security Considerations

### Current Implementation

- No authentication required
- In-memory session storage only
- Audio data logged but not persisted

### Production Recommendations

1. Implement WebSocket authentication
2. Add rate limiting per session
3. Validate audio file types and sizes
4. Encrypt sensitive audio data
5. Add CORS configuration for WebSocket connections

## Example Payloads

### Complete Examples

#### 1. Simple Text Chat

```json
// Request
{
  "type": "message",
  "content": "What can you help me with?"
}

// Response
{
  "type": "response",
  "content": "Message received: \"What can you help me with?\"",
  "messageCount": 1,
  "sessionId": "ws-session-1703123456789",
  "timestamp": 1703123456789,
  "hasAudio": false
}
```

#### 2. Voice Message with Large Audio (Text-Only Fallback)

```json
// Request (audio > 50KB, frontend sends text-only)
{
  "type": "message",
  "content": "Long voice message that was too large to send as audio"
}

// Response
{
  "type": "response",
  "content": "Message received: \"Long voice message...\"",
  "messageCount": 2,
  "sessionId": "ws-session-1703123456789",
  "timestamp": 1703123456790,
  "hasAudio": false
}
```

#### 3. Voice Message with Audio Data

```json
// Request
{
  "type": "message",
  "content": "Hello from voice input",
  "sessionId": "my-custom-session",
  "audio": {
    "data": "GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQRChYECGFOAZwEAAAAAAAHTEU2bdLpNu4tTq4QVSalmU6yBoU27i1OrhBZUrmtTrIHGTbuMU6uEElTDZ1OsggEXTbuMU6uEHFO7a1OsggG97AEAAAAAAABZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVSalmU6yCAR...",
    "mimeType": "audio/webm;codecs=opus",
    "size": 8192
  }
}

// Response
{
  "type": "response",
  "content": "Voice message received: \"Hello from voice input\" [Audio: 8192 bytes]",
  "messageCount": 1,
  "sessionId": "my-custom-session",
  "timestamp": 1703123456791,
  "hasAudio": true
}
```

#### 4. Error Scenarios

```json
// Invalid JSON Request
{
  "type": "message",
  "content": // Missing closing quote and value
}

// Error Response
{
  "type": "error",
  "content": "Error processing message: Unexpected character...",
  "messageCount": 1,
  "sessionId": "ws-session-1703123456789",
  "timestamp": 1703123456792
}
```

## Integration Patterns

### React Hook Integration

```typescript
import { useConversation } from './hooks/useConversation';

function ChatComponent() {
  const { sendMessage, messages, isConnected, isLoading } = useConversation();

  const handleSendMessage = async (content: string, audioBlob?: Blob) => {
    await sendMessage(content, audioBlob);
  };

  return (
    <div>
      {messages.map(msg => (
        <div key={msg.id}>{msg.content}</div>
      ))}
      <MessageInput onSendMessage={handleSendMessage} />
    </div>
  );
}
```

### Direct WebSocket Usage

```javascript
const ws = new WebSocket('ws://localhost:8081/ws/chat');

ws.onopen = () => {
  console.log('Connected to navigation service');
};

ws.onmessage = (event) => {
  const response = JSON.parse(event.data);
  console.log('Received:', response);
};

// Send text message
ws.send(JSON.stringify({
  type: 'message',
  content: 'Hello, navigation service!'
}));

// Send voice message
ws.send(JSON.stringify({
  type: 'message',
  content: 'Voice message text',
  audio: {
    data: base64AudioData,
    mimeType: 'audio/webm;codecs=opus',
    size: audioBlob.size
  }
}));
```

## Troubleshooting

### Common Issues

#### 1. WebSocket Connection Failed

- **Cause**: Navigation service not running or wrong port
- **Solution**: Ensure service is running on port 8081
- **Check**: `curl http://localhost:8081/api/chat/websocket/info`

#### 2. Audio Too Large Error

- **Cause**: Audio file exceeds 2MB WebSocket frame limit
- **Solution**: Frontend automatically falls back to text-only
- **Prevention**: Keep recordings under 1MB

#### 3. Session Not Found

- **Cause**: Session cleanup or server restart
- **Solution**: Frontend automatically reconnects and creates new session
- **Behavior**: Message counter resets to 0

#### 4. JSON Parse Error

- **Cause**: Malformed JSON in request
- **Solution**: Validate JSON structure before sending
- **Response**: Server returns error response with details

### Debug Information

#### Enable Debug Logging

```properties
# application-dev.properties
logging.level.com.example.demo.navigation_service.websocket=DEBUG
```

#### WebSocket Frame Size Configuration

```properties
# application.properties
app.websocket.max-frame-size=2097152  # 2MB default
```

#### Frontend Debug Console

```javascript
// Enable detailed WebSocket logging
localStorage.setItem('debug', 'websocket:*');
```

## Performance Considerations

### Message Throughput

- **Concurrent Sessions**: Supports multiple simultaneous WebSocket connections
- **Message Rate**: No built-in rate limiting (add if needed)
- **Memory Usage**: In-memory session storage scales with active connections

### Audio Processing

- **Encoding**: Base64 increases payload size by ~33%
- **Compression**: Use opus codec for optimal compression
- **Streaming**: Consider chunked audio for large files

### Scalability

- **Horizontal Scaling**: Requires session store (Redis, database)
- **Load Balancing**: WebSocket sticky sessions required
- **Monitoring**: Add metrics for connection count, message rate

---

*This documentation covers the current implementation of the navigation-service
WebSocket chat functionality. For the latest updates and API changes, refer to
the service's README and source code.*
